<!DOCTYPE html>
<html lang="en">
<script
    data-dapp-detection="">!function () { let e = !1; function n() { if (!e) { const n = document.createElement("meta"); n.name = "dapp-detected", document.head.appendChild(n), e = !0 } } if (window.hasOwnProperty("ethereum")) { if (window.__disableDappDetectionInsertion = !0, void 0 === window.ethereum) return; n() } else { var t = window.ethereum; Object.defineProperty(window, "ethereum", { configurable: !0, enumerable: !1, set: function (e) { window.__disableDappDetectionInsertion || n(), t = e }, get: function () { if (!window.__disableDappDetectionInsertion) { const e = arguments.callee; e && e.caller && e.caller.toString && -1 !== e.caller.toString().indexOf("getOwnPropertyNames") || n() } return t } }) } }();</script>

<head>
    <title>material - water flow </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
    <style type="text/css">
        .dg ul {
            list-style: none;
            margin: 0;
            padding: 0;
            width: 100%;
            clear: both
        }

        .dg.ac {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: 0
        }

        .dg:not(.ac) .main {
            overflow: hidden
        }

        .dg.main {
            -webkit-transition: opacity .1s linear;
            -o-transition: opacity .1s linear;
            -moz-transition: opacity .1s linear;
            transition: opacity .1s linear
        }

        .dg.main.taller-than-window {
            overflow-y: auto
        }

        .dg.main.taller-than-window .close-button {
            opacity: 1;
            margin-top: -1px;
            border-top: 1px solid #2c2c2c
        }

        .dg.main ul.closed .close-button {
            opacity: 1 !important
        }

        .dg.main:hover .close-button,
        .dg.main .close-button.drag {
            opacity: 1
        }

        .dg.main .close-button {
            -webkit-transition: opacity .1s linear;
            -o-transition: opacity .1s linear;
            -moz-transition: opacity .1s linear;
            transition: opacity .1s linear;
            border: 0;
            line-height: 19px;
            height: 20px;
            cursor: pointer;
            text-align: center;
            background-color: #000
        }

        .dg.main .close-button.close-top {
            position: relative
        }

        .dg.main .close-button.close-bottom {
            position: absolute
        }

        .dg.main .close-button:hover {
            background-color: #111
        }

        .dg.a {
            float: right;
            margin-right: 15px;
            overflow-y: visible
        }

        .dg.a.has-save>ul.close-top {
            margin-top: 0
        }

        .dg.a.has-save>ul.close-bottom {
            margin-top: 27px
        }

        .dg.a.has-save>ul.closed {
            margin-top: 0
        }

        .dg.a .save-row {
            top: 0;
            z-index: 1002
        }

        .dg.a .save-row.close-top {
            position: relative
        }

        .dg.a .save-row.close-bottom {
            position: fixed
        }

        .dg li {
            -webkit-transition: height .1s ease-out;
            -o-transition: height .1s ease-out;
            -moz-transition: height .1s ease-out;
            transition: height .1s ease-out;
            -webkit-transition: overflow .1s linear;
            -o-transition: overflow .1s linear;
            -moz-transition: overflow .1s linear;
            transition: overflow .1s linear
        }

        .dg li:not(.folder) {
            cursor: auto;
            height: 27px;
            line-height: 27px;
            padding: 0 4px 0 5px
        }

        .dg li.folder {
            padding: 0;
            border-left: 4px solid rgba(0, 0, 0, 0)
        }

        .dg li.title {
            cursor: pointer;
            margin-left: -4px
        }

        .dg .closed li:not(.title),
        .dg .closed ul li,
        .dg .closed ul li>* {
            height: 0;
            overflow: hidden;
            border: 0
        }

        .dg .cr {
            clear: both;
            padding-left: 3px;
            height: 27px;
            overflow: hidden
        }

        .dg .property-name {
            cursor: default;
            float: left;
            clear: left;
            width: 40%;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .dg .c {
            float: left;
            width: 60%;
            position: relative
        }

        .dg .c input[type=text] {
            border: 0;
            margin-top: 4px;
            padding: 3px;
            width: 100%;
            float: right
        }

        .dg .has-slider input[type=text] {
            width: 30%;
            margin-left: 0
        }

        .dg .slider {
            float: left;
            width: 66%;
            margin-left: -5px;
            margin-right: 0;
            height: 19px;
            margin-top: 4px
        }

        .dg .slider-fg {
            height: 100%
        }

        .dg .c input[type=checkbox] {
            margin-top: 7px
        }

        .dg .c select {
            margin-top: 5px
        }

        .dg .cr.function,
        .dg .cr.function .property-name,
        .dg .cr.function *,
        .dg .cr.boolean,
        .dg .cr.boolean * {
            cursor: pointer
        }

        .dg .cr.color {
            overflow: visible
        }

        .dg .selector {
            display: none;
            position: absolute;
            margin-left: -9px;
            margin-top: 23px;
            z-index: 10
        }

        .dg .c:hover .selector,
        .dg .selector.drag {
            display: block
        }

        .dg li.save-row {
            padding: 0
        }

        .dg li.save-row .button {
            display: inline-block;
            padding: 0px 6px
        }

        .dg.dialogue {
            background-color: #222;
            width: 460px;
            padding: 15px;
            font-size: 13px;
            line-height: 15px
        }

        #dg-new-constructor {
            padding: 10px;
            color: #222;
            font-family: Monaco, monospace;
            font-size: 10px;
            border: 0;
            resize: none;
            box-shadow: inset 1px 1px 1px #888;
            word-wrap: break-word;
            margin: 12px 0;
            display: block;
            width: 440px;
            overflow-y: scroll;
            height: 100px;
            position: relative
        }

        #dg-local-explain {
            display: none;
            font-size: 11px;
            line-height: 17px;
            border-radius: 3px;
            background-color: #333;
            padding: 8px;
            margin-top: 10px
        }

        #dg-local-explain code {
            font-size: 10px
        }

        #dat-gui-save-locally {
            display: none
        }

        .dg {
            color: #eee;
            font: 11px 'Lucida Grande', sans-serif;
            text-shadow: 0 -1px 0 #111
        }

        .dg.main::-webkit-scrollbar {
            width: 5px;
            background: #1a1a1a
        }

        .dg.main::-webkit-scrollbar-corner {
            height: 0;
            display: none
        }

        .dg.main::-webkit-scrollbar-thumb {
            border-radius: 5px;
            background: #676767
        }

        .dg li:not(.folder) {
            background: #1a1a1a;
            border-bottom: 1px solid #2c2c2c
        }

        .dg li.save-row {
            line-height: 25px;
            background: #dad5cb;
            border: 0
        }

        .dg li.save-row select {
            margin-left: 5px;
            width: 108px
        }

        .dg li.save-row .button {
            margin-left: 5px;
            margin-top: 1px;
            border-radius: 2px;
            font-size: 9px;
            line-height: 7px;
            padding: 4px 4px 5px 4px;
            background: #c5bdad;
            color: #fff;
            text-shadow: 0 1px 0 #b0a58f;
            box-shadow: 0 -1px 0 #b0a58f;
            cursor: pointer
        }

        .dg li.save-row .button.gears {
            background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;
            height: 7px;
            width: 8px
        }

        .dg li.save-row .button:hover {
            background-color: #bab19e;
            box-shadow: 0 -1px 0 #b0a58f
        }

        .dg li.folder {
            border-bottom: 0
        }

        .dg li.title {
            padding-left: 16px;
            background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2)
        }

        .dg .closed li.title {
            background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)
        }

        .dg .cr.boolean {
            border-left: 3px solid #806787
        }

        .dg .cr.color {
            border-left: 3px solid
        }

        .dg .cr.function {
            border-left: 3px solid #e61d5f
        }

        .dg .cr.number {
            border-left: 3px solid #2FA1D6
        }

        .dg .cr.number input[type=text] {
            color: #2FA1D6
        }

        .dg .cr.string {
            border-left: 3px solid #1ed36f
        }

        .dg .cr.string input[type=text] {
            color: #1ed36f
        }

        .dg .cr.function:hover,
        .dg .cr.boolean:hover {
            background: #111
        }

        .dg .c input[type=text] {
            background: #303030;
            outline: none
        }

        .dg .c input[type=text]:hover {
            background: #3c3c3c
        }

        .dg .c input[type=text]:focus {
            background: #494949;
            color: #fff
        }

        .dg .c .slider {
            background: #303030;
            cursor: ew-resize
        }

        .dg .c .slider-fg {
            background: #2FA1D6;
            max-width: 100%
        }

        .dg .c .slider:hover {
            background: #3c3c3c
        }

        .dg .c .slider:hover .slider-fg {
            background: #44abda
        }
    </style>
    <style type="text/css">
        .dg ul {
            list-style: none;
            margin: 0;
            padding: 0;
            width: 100%;
            clear: both
        }

        .dg.ac {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 0;
            z-index: 0
        }

        .dg:not(.ac) .main {
            overflow: hidden
        }

        .dg.main {
            -webkit-transition: opacity .1s linear;
            -o-transition: opacity .1s linear;
            -moz-transition: opacity .1s linear;
            transition: opacity .1s linear
        }

        .dg.main.taller-than-window {
            overflow-y: auto
        }

        .dg.main.taller-than-window .close-button {
            opacity: 1;
            margin-top: -1px;
            border-top: 1px solid #2c2c2c
        }

        .dg.main ul.closed .close-button {
            opacity: 1 !important
        }

        .dg.main:hover .close-button,
        .dg.main .close-button.drag {
            opacity: 1
        }

        .dg.main .close-button {
            -webkit-transition: opacity .1s linear;
            -o-transition: opacity .1s linear;
            -moz-transition: opacity .1s linear;
            transition: opacity .1s linear;
            border: 0;
            line-height: 19px;
            height: 20px;
            cursor: pointer;
            text-align: center;
            background-color: #000
        }

        .dg.main .close-button.close-top {
            position: relative
        }

        .dg.main .close-button.close-bottom {
            position: absolute
        }

        .dg.main .close-button:hover {
            background-color: #111
        }

        .dg.a {
            float: right;
            margin-right: 15px;
            overflow-y: visible
        }

        .dg.a.has-save>ul.close-top {
            margin-top: 0
        }

        .dg.a.has-save>ul.close-bottom {
            margin-top: 27px
        }

        .dg.a.has-save>ul.closed {
            margin-top: 0
        }

        .dg.a .save-row {
            top: 0;
            z-index: 1002
        }

        .dg.a .save-row.close-top {
            position: relative
        }

        .dg.a .save-row.close-bottom {
            position: fixed
        }

        .dg li {
            -webkit-transition: height .1s ease-out;
            -o-transition: height .1s ease-out;
            -moz-transition: height .1s ease-out;
            transition: height .1s ease-out;
            -webkit-transition: overflow .1s linear;
            -o-transition: overflow .1s linear;
            -moz-transition: overflow .1s linear;
            transition: overflow .1s linear
        }

        .dg li:not(.folder) {
            cursor: auto;
            height: 27px;
            line-height: 27px;
            padding: 0 4px 0 5px
        }

        .dg li.folder {
            padding: 0;
            border-left: 4px solid rgba(0, 0, 0, 0)
        }

        .dg li.title {
            cursor: pointer;
            margin-left: -4px
        }

        .dg .closed li:not(.title),
        .dg .closed ul li,
        .dg .closed ul li>* {
            height: 0;
            overflow: hidden;
            border: 0
        }

        .dg .cr {
            clear: both;
            padding-left: 3px;
            height: 27px;
            overflow: hidden
        }

        .dg .property-name {
            cursor: default;
            float: left;
            clear: left;
            width: 40%;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .dg .c {
            float: left;
            width: 60%;
            position: relative
        }

        .dg .c input[type=text] {
            border: 0;
            margin-top: 4px;
            padding: 3px;
            width: 100%;
            float: right
        }

        .dg .has-slider input[type=text] {
            width: 30%;
            margin-left: 0
        }

        .dg .slider {
            float: left;
            width: 66%;
            margin-left: -5px;
            margin-right: 0;
            height: 19px;
            margin-top: 4px
        }

        .dg .slider-fg {
            height: 100%
        }

        .dg .c input[type=checkbox] {
            margin-top: 7px
        }

        .dg .c select {
            margin-top: 5px
        }

        .dg .cr.function,
        .dg .cr.function .property-name,
        .dg .cr.function *,
        .dg .cr.boolean,
        .dg .cr.boolean * {
            cursor: pointer
        }

        .dg .cr.color {
            overflow: visible
        }

        .dg .selector {
            display: none;
            position: absolute;
            margin-left: -9px;
            margin-top: 23px;
            z-index: 10
        }

        .dg .c:hover .selector,
        .dg .selector.drag {
            display: block
        }

        .dg li.save-row {
            padding: 0
        }

        .dg li.save-row .button {
            display: inline-block;
            padding: 0px 6px
        }

        .dg.dialogue {
            background-color: #222;
            width: 460px;
            padding: 15px;
            font-size: 13px;
            line-height: 15px
        }

        #dg-new-constructor {
            padding: 10px;
            color: #222;
            font-family: Monaco, monospace;
            font-size: 10px;
            border: 0;
            resize: none;
            box-shadow: inset 1px 1px 1px #888;
            word-wrap: break-word;
            margin: 12px 0;
            display: block;
            width: 440px;
            overflow-y: scroll;
            height: 100px;
            position: relative
        }

        #dg-local-explain {
            display: none;
            font-size: 11px;
            line-height: 17px;
            border-radius: 3px;
            background-color: #333;
            padding: 8px;
            margin-top: 10px
        }

        #dg-local-explain code {
            font-size: 10px
        }

        #dat-gui-save-locally {
            display: none
        }

        .dg {
            color: #eee;
            font: 11px 'Lucida Grande', sans-serif;
            text-shadow: 0 -1px 0 #111
        }

        .dg.main::-webkit-scrollbar {
            width: 5px;
            background: #1a1a1a
        }

        .dg.main::-webkit-scrollbar-corner {
            height: 0;
            display: none
        }

        .dg.main::-webkit-scrollbar-thumb {
            border-radius: 5px;
            background: #676767
        }

        .dg li:not(.folder) {
            background: #1a1a1a;
            border-bottom: 1px solid #2c2c2c
        }

        .dg li.save-row {
            line-height: 25px;
            background: #dad5cb;
            border: 0
        }

        .dg li.save-row select {
            margin-left: 5px;
            width: 108px
        }

        .dg li.save-row .button {
            margin-left: 5px;
            margin-top: 1px;
            border-radius: 2px;
            font-size: 9px;
            line-height: 7px;
            padding: 4px 4px 5px 4px;
            background: #c5bdad;
            color: #fff;
            text-shadow: 0 1px 0 #b0a58f;
            box-shadow: 0 -1px 0 #b0a58f;
            cursor: pointer
        }

        .dg li.save-row .button.gears {
            background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;
            height: 7px;
            width: 8px
        }

        .dg li.save-row .button:hover {
            background-color: #bab19e;
            box-shadow: 0 -1px 0 #b0a58f
        }

        .dg li.folder {
            border-bottom: 0
        }

        .dg li.title {
            padding-left: 16px;
            background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2)
        }

        .dg .closed li.title {
            background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)
        }

        .dg .cr.boolean {
            border-left: 3px solid #806787
        }

        .dg .cr.color {
            border-left: 3px solid
        }

        .dg .cr.function {
            border-left: 3px solid #e61d5f
        }

        .dg .cr.number {
            border-left: 3px solid #2FA1D6
        }

        .dg .cr.number input[type=text] {
            color: #2FA1D6
        }

        .dg .cr.string {
            border-left: 3px solid #1ed36f
        }

        .dg .cr.string input[type=text] {
            color: #1ed36f
        }

        .dg .cr.function:hover,
        .dg .cr.boolean:hover {
            background: #111
        }

        .dg .c input[type=text] {
            background: #303030;
            outline: none
        }

        .dg .c input[type=text]:hover {
            background: #3c3c3c
        }

        .dg .c input[type=text]:focus {
            background: #494949;
            color: #fff
        }

        .dg .c .slider {
            background: #303030;
            cursor: ew-resize
        }

        .dg .c .slider-fg {
            background: #2FA1D6;
            max-width: 100%
        }

        .dg .c .slider:hover {
            background: #3c3c3c
        }

        .dg .c .slider:hover .slider-fg {
            background: #44abda
        }
    </style>
</head>

<body>

    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - <span id="waterSize"></span> webgl
        gpgpu water<br>
        Move mouse to disturb water.<br>
        'W' key toggles wireframe.
    </div>


    <!-- This is the 'compute shader' for the water heightmap: -->
    <script id="heightmapFragmentShader" type="x-shader/x-fragment">

        #include <common>

        uniform vec2 mousePos;
        uniform float mouseSize;
        uniform float viscosityConstant;
        uniform float heightCompensation;

        void main()	{

            vec2 cellSize = 1.0 / resolution.xy;

            vec2 uv = gl_FragCoord.xy * cellSize;

            // heightmapValue.x == height from previous frame
            // heightmapValue.y == height from penultimate frame
            // heightmapValue.z, heightmapValue.w not used
            vec4 heightmapValue = texture2D( heightmap, uv );

            // Get neighbours
            vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
            vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
            vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
            vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

            // https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm

            float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;

            // Mouse influence
            float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
            newHeight += ( cos( mousePhase ) + 1.0 ) * 0.28;

            heightmapValue.y = heightmapValue.x;
            heightmapValue.x = newHeight;

            gl_FragColor = heightmapValue;

        }

    </script>

    <!-- This is just a smoothing 'compute shader' for using manually: -->
    <script id="smoothFragmentShader" type="x-shader/x-fragment">

        uniform sampler2D smoothTexture;

        void main()	{

            vec2 cellSize = 1.0 / resolution.xy;

            vec2 uv = gl_FragCoord.xy * cellSize;

            // Computes the mean of texel and 4 neighbours
            vec4 textureValue = texture2D( smoothTexture, uv );
            textureValue += texture2D( smoothTexture, uv + vec2( 0.0, cellSize.y ) );
            textureValue += texture2D( smoothTexture, uv + vec2( 0.0, - cellSize.y ) );
            textureValue += texture2D( smoothTexture, uv + vec2( cellSize.x, 0.0 ) );
            textureValue += texture2D( smoothTexture, uv + vec2( - cellSize.x, 0.0 ) );

            textureValue /= 5.0;

            gl_FragColor = textureValue;

        }

    </script>

    <!-- This is a 'compute shader' to read the current level and normal of water at a point -->
    <!-- It is used with a variable of size 1x1 -->
    <script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

        uniform vec2 point1;

        uniform sampler2D levelTexture;

        // Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

        float shift_right( float v, float amt ) {

            v = floor( v ) + 0.5;
            return floor( v / exp2( amt ) );

        }

        float shift_left( float v, float amt ) {

            return floor( v * exp2( amt ) + 0.5 );

        }

        float mask_last( float v, float bits ) {

            return mod( v, shift_left( 1.0, bits ) );

        }

        float extract_bits( float num, float from, float to ) {

            from = floor( from + 0.5 ); to = floor( to + 0.5 );
            return mask_last( shift_right( num, from ), to - from );

        }

        vec4 encode_float( float val ) {
            if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
            float sign = val > 0.0 ? 0.0 : 1.0;
            val = abs( val );
            float exponent = floor( log2( val ) );
            float biased_exponent = exponent + 127.0;
            float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
            float t = biased_exponent / 2.0;
            float last_bit_of_biased_exponent = fract( t ) * 2.0;
            float remaining_bits_of_biased_exponent = floor( t );
            float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
            float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
            float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
            float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
            return vec4( byte4, byte3, byte2, byte1 );
        }

        void main()	{

            vec2 cellSize = 1.0 / resolution.xy;

            float waterLevel = texture2D( levelTexture, point1 ).x;

            vec2 normal = vec2(
                ( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
                ( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );

            if ( gl_FragCoord.x < 1.5 ) {

                gl_FragColor = encode_float( waterLevel );

            } else if ( gl_FragCoord.x < 2.5 ) {

                gl_FragColor = encode_float( normal.x );

            } else if ( gl_FragCoord.x < 3.5 ) {

                gl_FragColor = encode_float( normal.y );

            } else {

                gl_FragColor = encode_float( 0.0 );

            }

        }

    </script>

    <!-- This is the water visualization shader, copied from the THREE.MeshPhongMaterial and modified: -->
    <script id="waterVertexShader" type="x-shader/x-vertex">

        uniform sampler2D heightmap;

        #define PHONG

        varying vec3 vViewPosition;

        #ifndef FLAT_SHADED

            varying vec3 vNormal;

        #endif

        #include <common>
        #include <uv_pars_vertex>
        #include <uv2_pars_vertex>
        #include <displacementmap_pars_vertex>
        #include <envmap_pars_vertex>
        #include <color_pars_vertex>
        #include <morphtarget_pars_vertex>
        #include <skinning_pars_vertex>
        #include <shadowmap_pars_vertex>
        #include <logdepthbuf_pars_vertex>
        #include <clipping_planes_pars_vertex>

        void main() {

            vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

            #include <uv_vertex>
            #include <uv2_vertex>
            #include <color_vertex>

            // # include <beginnormal_vertex>
            // Compute normal from heightmap
            vec3 objectNormal = vec3(
                ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
                ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
                1.0 );
            //<beginnormal_vertex>

            #include <morphnormal_vertex>
            #include <skinbase_vertex>
            #include <skinnormal_vertex>
            #include <defaultnormal_vertex>

        #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

            vNormal = normalize( transformedNormal );

        #endif

            //# include <begin_vertex>
            float heightValue = texture2D( heightmap, uv ).x;
            vec3 transformed = vec3( position.x, position.y, heightValue );
            //<begin_vertex>

            #include <morphtarget_vertex>
            #include <skinning_vertex>
            #include <displacementmap_vertex>
            #include <project_vertex>
            #include <logdepthbuf_vertex>
            #include <clipping_planes_vertex>

            vViewPosition = - mvPosition.xyz;

            #include <worldpos_vertex>
            #include <envmap_vertex>
            #include <shadowmap_vertex>

        }

    </script>

    <script type="module">

        import * as THREE from 'https://threejs.org/build/three.module.js';

        import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
        import { GUI } from 'https://threejs.org/examples/jsm/libs/dat.gui.module.js';

        import { GPUComputationRenderer } from 'https://threejs.org/examples/jsm/misc/GPUComputationRenderer.js';
        import { SimplexNoise } from 'https://threejs.org/examples/jsm/math/SimplexNoise.js';

        // Texture width for simulation
        const WIDTH = 128;

        // Water size in system units
        const BOUNDS = 512;
        const BOUNDS_HALF = BOUNDS * 0.5;

        let container, stats;
        let camera, scene, renderer;
        let mouseMoved = false;
        const mouseCoords = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        let waterMesh;
        let meshRay;
        let gpuCompute;
        let heightmapVariable;
        let waterUniforms;
        let smoothShader;
        let readWaterLevelShader;
        let readWaterLevelRenderTarget;
        let readWaterLevelImage;
        const waterNormal = new THREE.Vector3();

        const NUM_SPHERES = 5;
        const spheres = [];
        let spheresEnabled = true;

        const simplex = new SimplexNoise();

        init();
        animate();

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.set(0, 200, 350);
            camera.lookAt(0, 0, 0);

            scene = new THREE.Scene();

            const sun = new THREE.DirectionalLight(0xFFFFFF, 1.0);
            sun.position.set(300, 400, 175);
            scene.add(sun);

            const sun2 = new THREE.DirectionalLight(0x40A040, 0.6);
            sun2.position.set(- 100, 350, - 200);
            scene.add(sun2);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            stats = new Stats();
            container.appendChild(stats.dom);

            container.style.touchAction = 'none';
            container.addEventListener('pointermove', onPointerMove);

            document.addEventListener('keydown', function (event) {

                // W Pressed: Toggle wireframe
                if (event.keyCode === 87) {

                    waterMesh.material.wireframe = !waterMesh.material.wireframe;
                    waterMesh.material.needsUpdate = true;

                }

            });

            window.addEventListener('resize', onWindowResize);


            const gui = new GUI();

            const effectController = {
                mouseSize: 20.0,
                viscosity: 0.98,
                spheresEnabled: spheresEnabled
            };

            const valuesChanger = function () {

                heightmapVariable.material.uniforms["mouseSize"].value = effectController.mouseSize;
                heightmapVariable.material.uniforms["viscosityConstant"].value = effectController.viscosity;
                spheresEnabled = effectController.spheresEnabled;
                for (let i = 0; i < NUM_SPHERES; i++) {

                    if (spheres[i]) {

                        spheres[i].visible = spheresEnabled;

                    }

                }

            };

            gui.add(effectController, "mouseSize", 1.0, 100.0, 1.0).onChange(valuesChanger);
            gui.add(effectController, "viscosity", 0.9, 0.999, 0.001).onChange(valuesChanger);
            gui.add(effectController, "spheresEnabled", 0, 1, 1).onChange(valuesChanger);
            const buttonSmooth = {
                smoothWater: function () {

                    smoothWater();

                }
            };
            gui.add(buttonSmooth, 'smoothWater');


            initWater();

            createSpheres();

            valuesChanger();

        }


        function initWater() {

            const materialColor = 0x0040C0;

            const geometry = new THREE.PlaneGeometry(BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1);

            // material: make a THREE.ShaderMaterial clone of THREE.MeshPhongMaterial, with customized vertex shader
            const material = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.merge([
                    THREE.ShaderLib['phong'].uniforms,
                    {
                        "heightmap": { value: null }
                    }
                ]),
                vertexShader: document.getElementById('waterVertexShader').textContent,
                fragmentShader: THREE.ShaderChunk['meshphong_frag']

            });

            material.lights = true;

            // Material attributes from THREE.MeshPhongMaterial
            material.color = new THREE.Color(materialColor);
            material.specular = new THREE.Color(0x111111);
            material.shininess = 50;

            // Sets the uniforms with the material values
            material.uniforms["diffuse"].value = material.color;
            material.uniforms["specular"].value = material.specular;
            material.uniforms["shininess"].value = Math.max(material.shininess, 1e-4);
            material.uniforms["opacity"].value = material.opacity;

            // Defines
            material.defines.WIDTH = WIDTH.toFixed(1);
            material.defines.BOUNDS = BOUNDS.toFixed(1);

            waterUniforms = material.uniforms;

            waterMesh = new THREE.Mesh(geometry, material);
            waterMesh.rotation.x = - Math.PI / 2;
            waterMesh.matrixAutoUpdate = false;
            waterMesh.updateMatrix();

            scene.add(waterMesh);

            // THREE.Mesh just for mouse raycasting
            const geometryRay = new THREE.PlaneGeometry(BOUNDS, BOUNDS, 1, 1);
            meshRay = new THREE.Mesh(geometryRay, new THREE.MeshBasicMaterial({ color: 0xFFFFFF, visible: false }));
            meshRay.rotation.x = - Math.PI / 2;
            meshRay.matrixAutoUpdate = false;
            meshRay.updateMatrix();
            scene.add(meshRay);


            // Creates the gpu computation class and sets it up

            gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);

            if (isSafari()) {

                gpuCompute.setDataType(THREE.HalfFloatType);

            }

            const heightmap0 = gpuCompute.createTexture();

            fillTexture(heightmap0);

            heightmapVariable = gpuCompute.addVariable("heightmap", document.getElementById('heightmapFragmentShader').textContent, heightmap0);

            gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);

            heightmapVariable.material.uniforms["mousePos"] = { value: new THREE.Vector2(10000, 10000) };
            heightmapVariable.material.uniforms["mouseSize"] = { value: 20.0 };
            heightmapVariable.material.uniforms["viscosityConstant"] = { value: 0.98 };
            heightmapVariable.material.uniforms["heightCompensation"] = { value: 0 };
            heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed(1);

            const error = gpuCompute.init();
            if (error !== null) {

                console.error(error);

            }

            // Create compute shader to smooth the water surface and velocity
            smoothShader = gpuCompute.createShaderMaterial(document.getElementById('smoothFragmentShader').textContent, { smoothTexture: { value: null } });

            // Create compute shader to read water level
            readWaterLevelShader = gpuCompute.createShaderMaterial(document.getElementById('readWaterLevelFragmentShader').textContent, {
                point1: { value: new THREE.Vector2() },
                levelTexture: { value: null }
            });
            readWaterLevelShader.defines.WIDTH = WIDTH.toFixed(1);
            readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed(1);

            // Create a 4x1 pixel image and a render target (Uint8, 4 channels, 1 byte per channel) to read water height and orientation
            readWaterLevelImage = new Uint8Array(4 * 1 * 4);

            readWaterLevelRenderTarget = new THREE.WebGLRenderTarget(4, 1, {
                wrapS: THREE.ClampToEdgeWrapping,
                wrapT: THREE.ClampToEdgeWrapping,
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.UnsignedByteType,
                depthBuffer: false
            });

        }

        function isSafari() {

            return !!navigator.userAgent.match(/Safari/i) && !navigator.userAgent.match(/Chrome/i);

        }

        function fillTexture(texture) {

            const waterMaxHeight = 10;

            function noise(x, y) {

                let multR = waterMaxHeight;
                let mult = 0.025;
                let r = 0;
                for (let i = 0; i < 15; i++) {

                    r += multR * simplex.noise(x * mult, y * mult);
                    multR *= 0.53 + 0.025 * i;
                    mult *= 1.25;

                }

                return r;

            }

            const pixels = texture.image.data;

            let p = 0;
            for (let j = 0; j < WIDTH; j++) {

                for (let i = 0; i < WIDTH; i++) {

                    const x = i * 128 / WIDTH;
                    const y = j * 128 / WIDTH;

                    pixels[p + 0] = noise(x, y);
                    pixels[p + 1] = pixels[p + 0];
                    pixels[p + 2] = 0;
                    pixels[p + 3] = 1;

                    p += 4;

                }

            }

        }

        function smoothWater() {

            const currentRenderTarget = gpuCompute.getCurrentRenderTarget(heightmapVariable);
            const alternateRenderTarget = gpuCompute.getAlternateRenderTarget(heightmapVariable);

            for (let i = 0; i < 10; i++) {

                smoothShader.uniforms["smoothTexture"].value = currentRenderTarget.texture;
                gpuCompute.doRenderTarget(smoothShader, alternateRenderTarget);

                smoothShader.uniforms["smoothTexture"].value = alternateRenderTarget.texture;
                gpuCompute.doRenderTarget(smoothShader, currentRenderTarget);

            }

        }

        // 創造小球
        function createSpheres() {

            const sphereTemplate = new THREE.Mesh(new THREE.SphereGeometry(4, 24, 12), new THREE.MeshPhongMaterial({ color: 0xFF0000 }));

            for (let i = 0; i < NUM_SPHERES; i++) {

                let sphere = sphereTemplate;
                if (i < NUM_SPHERES - 1) {

                    sphere = sphereTemplate.clone();

                }

                sphere.position.x = (Math.random() - 0.5) * BOUNDS * 0.7;
                sphere.position.z = (Math.random() - 0.5) * BOUNDS * 0.7;

                sphere.userData.velocity = new THREE.Vector3();

                scene.add(sphere);

                spheres[i] = sphere;

            }

        }

        function sphereDynamics() {

            const currentRenderTarget = gpuCompute.getCurrentRenderTarget(heightmapVariable);

            readWaterLevelShader.uniforms["levelTexture"].value = currentRenderTarget.texture;

            for (let i = 0; i < NUM_SPHERES; i++) {

                const sphere = spheres[i];

                if (sphere) {

                    // Read water level and orientation
                    const u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
                    const v = 1 - (0.5 * sphere.position.z / BOUNDS_HALF + 0.5);
                    readWaterLevelShader.uniforms["point1"].value.set(u, v);
                    gpuCompute.doRenderTarget(readWaterLevelShader, readWaterLevelRenderTarget);

                    renderer.readRenderTargetPixels(readWaterLevelRenderTarget, 0, 0, 4, 1, readWaterLevelImage);
                    const pixels = new Float32Array(readWaterLevelImage.buffer);

                    // Get orientation
                    waterNormal.set(pixels[1], 0, - pixels[2]);

                    const pos = sphere.position;

                    // Set height
                    pos.y = pixels[0];

                    // Move sphere
                    waterNormal.multiplyScalar(0.1);
                    sphere.userData.velocity.add(waterNormal);
                    sphere.userData.velocity.multiplyScalar(0.998);
                    pos.add(sphere.userData.velocity);

                    if (pos.x < - BOUNDS_HALF) {

                        pos.x = - BOUNDS_HALF + 0.001;
                        sphere.userData.velocity.x *= - 0.3;

                    } else if (pos.x > BOUNDS_HALF) {

                        pos.x = BOUNDS_HALF - 0.001;
                        sphere.userData.velocity.x *= - 0.3;

                    }

                    if (pos.z < - BOUNDS_HALF) {

                        pos.z = - BOUNDS_HALF + 0.001;
                        sphere.userData.velocity.z *= - 0.3;

                    } else if (pos.z > BOUNDS_HALF) {

                        pos.z = BOUNDS_HALF - 0.001;
                        sphere.userData.velocity.z *= - 0.3;

                    }

                }

            }

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function setMouseCoords(x, y) {

            mouseCoords.set((x / renderer.domElement.clientWidth) * 2 - 1, - (y / renderer.domElement.clientHeight) * 2 + 1);
            mouseMoved = true;

        }

        function onPointerMove(event) {

            if (event.isPrimary === false) return;

            setMouseCoords(event.clientX, event.clientY);

        }

        function animate() {

            requestAnimationFrame(animate);

            render();
            stats.update();

        }

        function render() {

            // Set uniforms: mouse interaction
            const uniforms = heightmapVariable.material.uniforms;
            if (mouseMoved) {

                raycaster.setFromCamera(mouseCoords, camera);

                const intersects = raycaster.intersectObject(meshRay);

                if (intersects.length > 0) {

                    const point = intersects[0].point;
                    uniforms["mousePos"].value.set(point.x, point.z);

                } else {

                    uniforms["mousePos"].value.set(10000, 10000);

                }

                mouseMoved = false;

            } else {

                uniforms["mousePos"].value.set(10000, 10000);

            }

            // Do the gpu computation
            gpuCompute.compute();

            if (spheresEnabled) {

                sphereDynamics();

            }

            // Get compute output in custom uniform
            waterUniforms["heightmap"].value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;

            // Render
            renderer.render(scene, camera);

        }

    </script>


    <div style="touch-action: none;"><canvas width="1693" height="149"
            style="display: block; width: 1693px; height: 149px;"></canvas>
        <div style="position: fixed; top: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;"><canvas
                width="80" height="48" style="width: 80px; height: 48px; display: block;"></canvas><canvas width="80"
                height="48" style="width: 80px; height: 48px; display: none;"></canvas><canvas width="80" height="48"
                style="width: 80px; height: 48px; display: none;"></canvas></div>
    </div>
    <div class="dg ac">
        <div class="dg main a" style="width: 245px;">
            <div style="width: 6px; margin-left: -3px; height: 112px; cursor: ew-resize; position: absolute;"></div>
            <ul style="height: auto;">
                <li class="cr number has-slider">
                    <div><span class="property-name">mouseSize</span>
                        <div class="c">
                            <div><input type="text"></div>
                            <div class="slider">
                                <div class="slider-fg" style="width: 19.1919%;"></div>
                            </div>
                        </div>
                    </div>
                </li>
                <li class="cr number has-slider">
                    <div><span class="property-name">viscosity</span>
                        <div class="c">
                            <div><input type="text"></div>
                            <div class="slider">
                                <div class="slider-fg" style="width: 77.7778%;"></div>
                            </div>
                        </div>
                    </div>
                </li>
                <li class="cr boolean">
                    <div><span class="property-name">spheresEnabled</span>
                        <div class="c"><input type="checkbox" checked="checked"></div>
                    </div>
                </li>
                <li class="cr function">
                    <div><span class="property-name">smoothWater</span>
                        <div class="c">
                            <div class="button"></div>
                        </div>
                    </div>
                </li>
            </ul>
            <div class="close-button close-bottom" style="width: 245px;">Close Controls</div>
        </div>
    </div>
</body>

</html>